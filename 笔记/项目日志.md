# 云图库平台项目日志



# 一. 用户登录功能



### 1.为什么要实现 `Serializable` 接口？

```java
/**
 * 用户登录请求
 */
@Data
public class UserLoginRequest implements Serializable {

    private static final long serialVersionUID = 8735650154179439661L;

    /**
     * 账号
     */
    private String userAccount;

    /**
     * 密码
     */
    private String userPassword;
}
```

实现 `Serializable` 接口是为了让这个 `UserLoginRequest` 对象能够被**序列化**和**反序列化**。

- **序列化 (Serialization)**：是将 Java 对象转换为字节流的过程。
- **反序列化 (Deserialization)**：是将字节流还原为 Java 对象的过程。

在分布式系统或需要持久化 Session 的场景中（例如，将 Session 存入 Redis），这个接口至关重要，因为它允许对象在网络中传输或被存储到硬盘/缓存中。

### 2.**`serialVersionUID` 的作用**

- **`serialVersionUID`** 是序列化过程中用来验证版本一致性的唯一标识符。
- **目的**：它的核心作用是确保在**反序列化**时，加载的类版本与当初**序列化**时的类版本是兼容的。
- **为什么需要显式声明**：
  - **版本控制**：如果您不声明，JVM 会根据类的结构（字段、方法等）自动生成一个。一旦您修改了类的结构（比如增加一个字段），自动生成的值就会改变，导致旧的序列化数据无法反序列化回新版本的类，从而报错。
  - **稳定性**：通过**显式地定义一个固定的 `serialVersionUID`**，您等于在告诉 JVM：“即使我未来给这个类增加了一些不影响核心数据的字段，也请继续兼容旧的序列化数据。” 这是一种保证序列化稳定性和向后兼容性的最佳实践。





## 2.用户鉴权方法

通过session实现，当用户登录后，把用户信息存入session 中， 获取用户信息时，把



# 二.用户权限管理

1.通过自定义注解，以及aop切面，实现权限隔离



















# 三.图片模块

管理员上传 修改  删除

不使用OSS  使用腾讯云 cos 



api与sdk区别

api是开放接口，需要自己写请求，发请求

sdk是封装好的，直接拿来用，而且自带加密之类的功能







## 一.图片上传功能

本段代码实现了一个文件上传接口，它采用的是“**服务器中转**”模式。即前端将文件上传到我们的后端服务器，后端服务器再将文件转发并存储到云端对象存储（如腾讯云 COS 或阿里云 OSS）中.

```java
@AuthCheck(mushRole = UserConstant.ADMIN_ROLE)
    @PostMapping("/test/upload")
    public BaseResponse<String> testUpload(@RequestPart("file") MultipartFile multipartFile) {
        //文件目录
        String filename = multipartFile.getOriginalFilename();
        String filePath = String.format("/test/%s", filename);

        File file =null;

        try {
            file= File.createTempFile(filePath, null);
            multipartFile.transferTo(file);
            cosManager.putObject(filePath, file);
            return ResultUtils.success(filePath);
        } catch (IOException e) {
            log.info("文件上传失败 path={}", filePath, e);
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "文件上传失败");
        }
        finally {
            if (file != null) {
                boolean delete = file.delete();
                if (!delete) {
                    log.info("文件删除失败 file={}", file.getAbsolutePath());
                }
            }
        }

    }
```

### **1. MultipartFile的形参与注解**

```
@RequestPart("file") MultipartFile multipartFile
```

- **`MultipartFile`**:
  - 这是 Spring MVC 框架提供的一个**接口**，专门用来**封装上传的文件**。
  - 当前端通过 `multipart/form-data` 格式上传文件时，Spring 会自动将文件数据包装成一个 `MultipartFile` 对象。
  - 通过这个对象，我们可以轻松获取文件的各种信息，例如：
    - `multipartFile.getOriginalFilename()`: 获取原始文件名。
    - `multipartFile.getSize()`: 获取文件大小。
    - `multipartFile.getContentType()`: 获取文件类型。
    - `multipartFile.getBytes()`: 以字节数组形式获取文件内容（用于内存操作）。
    - `multipartFile.transferTo(File dest)`: 将文件内容保存到服务器本地的一个文件中（用于磁盘操作）。
- **`@RequestPart("file")`**:
  - 这是一个**参数注解**，它的作用是**明确地**告诉 Spring：“**请从这个 `multipart/form-data` 请求中，找到名为 `file` 的那个部分，然后把它绑定到 `multipartFile` 这个参数上。**”
  - 在前端，这意味着 `<input type="file" name="file">` 中的 `name` 属性，或者 `FormData` 对象中 `append("file", fileObject)` 的键，**必须是 `file`**。

### 2.储存中转

**“内存流式直传”的对比**：这种“中转”模式相比于直接使用 `file.getBytes()` 的“内存流式”模式，虽然多了一步磁盘I/O，但对于处理非常大的文件更为安全（可以避免内存溢出），也方便在上传到云端前，对文件本身进行一些需要物理文件路径的预处理。

### 3.上传图像注意事项

在上传时数据时候，如果文件大于1MB spring框架会自动拦截请求信息，修改配置文件生生效

```yaml
  spring:
   servlet:
     multipart:
       max-file-size: 10MB
```

### 4.上传图像实现方法

如何实现，调用腾讯云的cos ，将cos的cosClient注入容器  

如何解析图片属性   使用腾讯云的数据万象实现，提供上传图片的各种信息







# 四.用户上传图片以及审核

用户跟管理员共享上传api，但是用户上传后默认审核状态为待审核，管理员默认上传后过审



## url上传

重构上传方法，使用设计模式——模板方法  

声明一个抽象的父类，  使用url上传和文件上传继承并实现抽象方法，实现解耦



