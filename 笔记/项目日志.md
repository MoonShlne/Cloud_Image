# 云图库平台项目日志



# 一. 用户登录功能



### 1.为什么要实现 `Serializable` 接口？

```java
/**
 * 用户登录请求
 */
@Data
public class UserLoginRequest implements Serializable {

    private static final long serialVersionUID = 8735650154179439661L;

    /**
     * 账号
     */
    private String userAccount;

    /**
     * 密码
     */
    private String userPassword;
}
```

实现 `Serializable` 接口是为了让这个 `UserLoginRequest` 对象能够被**序列化**和**反序列化**。

- **序列化 (Serialization)**：是将 Java 对象转换为字节流的过程。
- **反序列化 (Deserialization)**：是将字节流还原为 Java 对象的过程。

在分布式系统或需要持久化 Session 的场景中（例如，将 Session 存入 Redis），这个接口至关重要，因为它允许对象在网络中传输或被存储到硬盘/缓存中。

### 2.**`serialVersionUID` 的作用**

- **`serialVersionUID`** 是序列化过程中用来验证版本一致性的唯一标识符。
- **目的**：它的核心作用是确保在**反序列化**时，加载的类版本与当初**序列化**时的类版本是兼容的。
- **为什么需要显式声明**：
  - **版本控制**：如果您不声明，JVM 会根据类的结构（字段、方法等）自动生成一个。一旦您修改了类的结构（比如增加一个字段），自动生成的值就会改变，导致旧的序列化数据无法反序列化回新版本的类，从而报错。
  - **稳定性**：通过**显式地定义一个固定的 `serialVersionUID`**，您等于在告诉 JVM：“即使我未来给这个类增加了一些不影响核心数据的字段，也请继续兼容旧的序列化数据。” 这是一种保证序列化稳定性和向后兼容性的最佳实践。





## 2.用户鉴权方法

通过session实现，当用户登录后，把用户信息存入session 中， 获取用户信息时，把



# 二.用户权限管理

1.通过自定义注解，以及aop切面，实现权限隔离



















# 三.图片模块

管理员上传 修改  删除

不使用OSS  使用腾讯云 cos 



api与sdk区别

api是开放接口，需要自己写请求，发请求

sdk是封装好的，直接拿来用，而且自带加密之类的功能







## 一.图片上传功能

本段代码实现了一个文件上传接口，它采用的是“**服务器中转**”模式。即前端将文件上传到我们的后端服务器，后端服务器再将文件转发并存储到云端对象存储（如腾讯云 COS 或阿里云 OSS）中.

```java
@AuthCheck(mushRole = UserConstant.ADMIN_ROLE)
    @PostMapping("/test/upload")
    public BaseResponse<String> testUpload(@RequestPart("file") MultipartFile multipartFile) {
        //文件目录
        String filename = multipartFile.getOriginalFilename();
        String filePath = String.format("/test/%s", filename);

        File file =null;

        try {
            file= File.createTempFile(filePath, null);
            multipartFile.transferTo(file);
            cosManager.putObject(filePath, file);
            return ResultUtils.success(filePath);
        } catch (IOException e) {
            log.info("文件上传失败 path={}", filePath, e);
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "文件上传失败");
        }
        finally {
            if (file != null) {
                boolean delete = file.delete();
                if (!delete) {
                    log.info("文件删除失败 file={}", file.getAbsolutePath());
                }
            }
        }

    }
```

### **1. MultipartFile的形参与注解**

```
@RequestPart("file") MultipartFile multipartFile
```

- **`MultipartFile`**:
  - 这是 Spring MVC 框架提供的一个**接口**，专门用来**封装上传的文件**。
  - 当前端通过 `multipart/form-data` 格式上传文件时，Spring 会自动将文件数据包装成一个 `MultipartFile` 对象。
  - 通过这个对象，我们可以轻松获取文件的各种信息，例如：
    - `multipartFile.getOriginalFilename()`: 获取原始文件名。
    - `multipartFile.getSize()`: 获取文件大小。
    - `multipartFile.getContentType()`: 获取文件类型。
    - `multipartFile.getBytes()`: 以字节数组形式获取文件内容（用于内存操作）。
    - `multipartFile.transferTo(File dest)`: 将文件内容保存到服务器本地的一个文件中（用于磁盘操作）。
- **`@RequestPart("file")`**:
  - 这是一个**参数注解**，它的作用是**明确地**告诉 Spring：“**请从这个 `multipart/form-data` 请求中，找到名为 `file` 的那个部分，然后把它绑定到 `multipartFile` 这个参数上。**”
  - 在前端，这意味着 `<input type="file" name="file">` 中的 `name` 属性，或者 `FormData` 对象中 `append("file", fileObject)` 的键，**必须是 `file`**。

### 2.储存中转

**“内存流式直传”的对比**：这种“中转”模式相比于直接使用 `file.getBytes()` 的“内存流式”模式，虽然多了一步磁盘I/O，但对于处理非常大的文件更为安全（可以避免内存溢出），也方便在上传到云端前，对文件本身进行一些需要物理文件路径的预处理。

### 3.上传图像注意事项

在上传时数据时候，如果文件大于1MB spring框架会自动拦截请求信息，修改配置文件生生效

```yaml
  spring:
   servlet:
     multipart:
       max-file-size: 10MB
```

### 4.上传图像实现方法

如何实现，调用腾讯云的cos ，将cos的cosClient注入容器  

如何解析图片属性   使用腾讯云的数据万象实现，提供上传图片的各种信息



# 四.用户上传图片以及审核

用户跟管理员共享上传api，但是用户上传后默认审核状态为待审核，管理员默认上传后过审



## url上传

重构上传方法，使用设计模式——模板方法  

声明一个抽象的父类，  使用url上传和文件上传继承并实现抽象方法，实现解耦



## 批量抓取图片  

本质是爬取图片网站，然后把图片上传到自己的cos



如何爬取到接口网站，小技巧，在图片网页，往下拉，获得新图片就会发送新的请求



解析文档用 Jsoup



bug：爬取的图片路径非常复杂，还有各种符号，抓取的图片链接

















# 五.图片优化

## **一、 缓存的核心思想**



为了提升图片等热点数据的访问速度，减轻数据库压力，我们采用多级缓存策略。核心逻辑是：**优先访问速度最快的缓存，逐级查询，最后才访问数据库**。



## **二、 缓存方案**

### **1. Redis 缓存（分布式缓存）**

- **作用**：作为主缓存层，在多个应用实例之间共享数据。
- **优点**：数据集中管理，应用重启后数据不丢失（配置持久化后）。
- **缺点**：需要通过网络读写，性能相比本地内存有损耗。
- **优化**：
  - **缓存雪崩**：当大量缓存（如同一批次的图片）在同一时间点同步失效时，会导致所有请求瞬间全部打向数据库，造成服务瘫痪。
  - **解决方案**：为不同的 Key 设置**随机的过期时间**，分散失效时间点，避免集中失效。

### **2. 本地缓存 (Caffeine)**

https://github.com/ben-manes/caffeine?tab=readme-ov-file

- **作用**：作为第一级缓存（L1 Cache），直接在应用服务器的内存中存储数据。
- **优点**：
  - **极致性能**：直接从内存读取，**无需网络传输**，速度极快，性能远高于 Redis。
  - **功能强大**：Caffeine 是 Java 主流的本地缓存技术，支持精确控制缓存数量、多种淘汰策略（如 LRU）、异步操作和线程安全。
- **缺点**：
  - 数据存储在单机内存中，无法在多个服务实例间共享。
  - 应用重启后，本地缓存会丢失。

```java
/**
 * 分页获取图片视图列表 (使用 Caffeine 本地缓存)
 */
@PostMapping("/list/page/vo/localCache")
@ApiOperation(value = "分页获取图片视图列表 本地缓存")
public BaseResponse<Page<PictureVO>> listPictureVOByPageWithLocalCache(@RequestBody PictureQueryRequest pictureQueryRequest, HttpServletRequest request) {
    // ... (省略参数校验、分页限制等前置代码)

    // 1. 生成缓存 Key
    // 将整个查询请求对象转换为 JSON 字符串
    String jsonStr = JSONUtil.toJsonStr(pictureQueryRequest);
    // 对 JSON 字符串进行 MD5 哈希，生成唯一的 Key
    String hashKey = DigestUtils.md5DigestAsHex(jsonStr.getBytes());
    String cacheKey = String.format("cloudimage:listPictureVOByPage:%s", hashKey);

    // 2. 查询本地缓存
    String cachedValue = LOCAL_CACHE.getIfPresent(cacheKey);
    if (cachedValue != null) {
        // 缓存命中：将 JSON 字符串反序列化为 Page 对象并直接返回
        Page<PictureVO> cachedPage = JSONUtil.toBean(cachedValue, Page.class);
        return ResultUtils.success(cachedPage);
    }

    // 3. 缓存未命中：查询数据库
    Page<Picture> picturePage = pictureService.page(new Page<>(current, size),
            pictureService.getQueryWrapper(pictureQueryRequest));

    // 4. 将数据库结果转换为 VO
    Page<PictureVO> pictureVOPage = pictureService.getPictureVOPage(picturePage, request);
    
    // 5. 将结果存入本地缓存
    String cacheValue = JSONUtil.toJsonStr(pictureVOPage);
    LOCAL_CACHE.put(cacheKey, cacheValue);

    // 6. 返回结果
    return ResultUtils.success(pictureVOPage);
}
```

## **三、 多级缓存（L1 + L2 架构）**

结合本地缓存和 Redis 缓存，构建一个更健壮、性能更高的多级缓存体系。

- **读取流程**：
  1. **查 L1 (Caffeine 本地缓存)**：优先从本地内存中读取数据。如果命中，直接返回。
  2. **查 L2 (Redis 分布式缓存)**：如果本地缓存未命中，则查询 Redis。
  3. **L2 命中**：如果 Redis 命中，将数据返回给用户，并**同时写入本地缓存**（L1），以便下次能更快访问。
  4. **L2 未命中**：查询数据库，并将结果**同时写入 Redis (L2) 和本地缓存 (L1)**，最后返回给用户。
- **数据更新**：当数据发生变更时（如图片被删除或修改），必须**同时失效（删除）** L2 (Redis) 和 L1 (本地缓存) 中的数据，以保证数据一致性。

## **四、 缓存的经典问题与解决方案**

1. **缓存击穿**
   - **现象**：某个**热点数据**（如爆款图片）的缓存刚过期，瞬间有大量并发请求访问这个数据，导致这些请求全部穿透到数据库，造成压力。
   - **解决方案**：
     - 设置热点数据永不过期或超长过期时间。
     - 使用**互斥锁**（如 Redisson 的 `RLock`）：当缓存未命中时，只允许第一个请求去查询数据库并写回缓存，其他请求短暂等待后直接读取新写入的缓存。
2. **缓存穿透**
   - **现象**：用户（或黑客）频繁请求一个**数据库中根本不存在**的数据。每次请求都会穿透缓存，直接打到数据库，导致数据库压力。
   - **解决方案**：
     - **缓存空值**：当数据库查询不到结果时，也在 Redis 中缓存一个特殊的空值（如 `null` 或 `""`），并设置一个较短的过期时间。
     - **布隆过滤器 (Bloom Filter)**：一种高效的数据结构，用于快速判断一个元素“一定不存在”或“可能存在”，在缓存之前拦截掉无效请求。
3. **缓存雪崩**
   - **现象**：大量缓存数据在**同一时刻**集体过期，导致所有请求都打向数据库，造成系统崩溃。
   - **解决方案**：
     - **设置随机过期时间**：在基础过期时间上增加一个随机值，错开失效时间点。
     - 使用多级缓存，L1 和 L2 同时失效的概率极低。





