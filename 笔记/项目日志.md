# 云图库平台项目日志



# 一. 用户登录功能



### 1.为什么要实现 `Serializable` 接口？

```java
/**
 * 用户登录请求
 */
@Data
public class UserLoginRequest implements Serializable {

    private static final long serialVersionUID = 8735650154179439661L;

    /**
     * 账号
     */
    private String userAccount;

    /**
     * 密码
     */
    private String userPassword;
}
```

实现 `Serializable` 接口是为了让这个 `UserLoginRequest` 对象能够被**序列化**和**反序列化**。

- **序列化 (Serialization)**：是将 Java 对象转换为字节流的过程。
- **反序列化 (Deserialization)**：是将字节流还原为 Java 对象的过程。

在分布式系统或需要持久化 Session 的场景中（例如，将 Session 存入 Redis），这个接口至关重要，因为它允许对象在网络中传输或被存储到硬盘/缓存中。

### 2.**`serialVersionUID` 的作用**

- **`serialVersionUID`** 是序列化过程中用来验证版本一致性的唯一标识符。
- **目的**：它的核心作用是确保在**反序列化**时，加载的类版本与当初**序列化**时的类版本是兼容的。
- **为什么需要显式声明**：
  - **版本控制**：如果您不声明，JVM 会根据类的结构（字段、方法等）自动生成一个。一旦您修改了类的结构（比如增加一个字段），自动生成的值就会改变，导致旧的序列化数据无法反序列化回新版本的类，从而报错。
  - **稳定性**：通过**显式地定义一个固定的 `serialVersionUID`**，您等于在告诉 JVM：“即使我未来给这个类增加了一些不影响核心数据的字段，也请继续兼容旧的序列化数据。” 这是一种保证序列化稳定性和向后兼容性的最佳实践。





## 2.用户鉴权方法

通过session实现，当用户登录后，把用户信息存入session 中， 获取用户信息时

每次重启服务器session都会丢失   使用spring redis 持久化session 

### Session 持久化 (Redis)

- **目的**：解决分布式系统中 Session 共享的问题，避免因服务器重启或负载均衡导致用户登录状态丢失。
- **实现**：
  1. 在项目中引入 Redis Session 的依赖。
  2. 修改 `application.yml` 或 `application.properties` 配置文件，指定 Session 使用 Redis 存储。
  3. 将需要存入 Session 的对象实现 `java.io.Serializable` 接口。
- **关键知识点**：
  - **为什么要实现 `Serializable`？**
    - Spring Session 默认使用 **JDK 序列化** (`DefaultSerializer`) 机制。
    - 该机制要求被序列化并存入 Redis 的 Java 对象必须实现 `Serializable` 标记接口，否则会抛出序列化异常。
  - **Jackson 与 JDK 序列化的区别**
    - **Jackson**：主要用于 **HTTP 请求/响应体** 的 JSON 序列化与反序列化，是应用层的数据格式转换。
    - **JDK 序列化**：是 Java 原生的对象持久化机制，用于将对象转换为二进制流，以便在网络上传输或存储到磁盘/数据库（如 Redis）。Spring Session 默认采用后者。



# 二.用户权限管理

1.通过自定义注解，以及aop切面，实现权限隔离



















# 三.图片模块

管理员上传 修改  删除

不使用OSS  使用腾讯云 cos 



api与sdk区别

api是开放接口，需要自己写请求，发请求

sdk是封装好的，直接拿来用，而且自带加密之类的功能







## 一.图片上传功能

本段代码实现了一个文件上传接口，它采用的是“**服务器中转**”模式。即前端将文件上传到我们的后端服务器，后端服务器再将文件转发并存储到云端对象存储（如腾讯云 COS 或阿里云 OSS）中.

```java
@AuthCheck(mushRole = UserConstant.ADMIN_ROLE)
    @PostMapping("/test/upload")
    public BaseResponse<String> testUpload(@RequestPart("file") MultipartFile multipartFile) {
        //文件目录
        String filename = multipartFile.getOriginalFilename();
        String filePath = String.format("/test/%s", filename);

        File file =null;

        try {
            file= File.createTempFile(filePath, null);
            multipartFile.transferTo(file);
            cosManager.putObject(filePath, file);
            return ResultUtils.success(filePath);
        } catch (IOException e) {
            log.info("文件上传失败 path={}", filePath, e);
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "文件上传失败");
        }
        finally {
            if (file != null) {
                boolean delete = file.delete();
                if (!delete) {
                    log.info("文件删除失败 file={}", file.getAbsolutePath());
                }
            }
        }

    }
```

### **1. MultipartFile的形参与注解**

```
@RequestPart("file") MultipartFile multipartFile
```

- **`MultipartFile`**:
  - 这是 Spring MVC 框架提供的一个**接口**，专门用来**封装上传的文件**。
  - 当前端通过 `multipart/form-data` 格式上传文件时，Spring 会自动将文件数据包装成一个 `MultipartFile` 对象。
  - 通过这个对象，我们可以轻松获取文件的各种信息，例如：
    - `multipartFile.getOriginalFilename()`: 获取原始文件名。
    - `multipartFile.getSize()`: 获取文件大小。
    - `multipartFile.getContentType()`: 获取文件类型。
    - `multipartFile.getBytes()`: 以字节数组形式获取文件内容（用于内存操作）。
    - `multipartFile.transferTo(File dest)`: 将文件内容保存到服务器本地的一个文件中（用于磁盘操作）。
- **`@RequestPart("file")`**:
  - 这是一个**参数注解**，它的作用是**明确地**告诉 Spring：“**请从这个 `multipart/form-data` 请求中，找到名为 `file` 的那个部分，然后把它绑定到 `multipartFile` 这个参数上。**”
  - 在前端，这意味着 `<input type="file" name="file">` 中的 `name` 属性，或者 `FormData` 对象中 `append("file", fileObject)` 的键，**必须是 `file`**。

### 2.储存中转

**“内存流式直传”的对比**：这种“中转”模式相比于直接使用 `file.getBytes()` 的“内存流式”模式，虽然多了一步磁盘I/O，但对于处理非常大的文件更为安全（可以避免内存溢出），也方便在上传到云端前，对文件本身进行一些需要物理文件路径的预处理。

### 3.上传图像注意事项

在上传时数据时候，如果文件大于1MB spring框架会自动拦截请求信息，修改配置文件生生效

```yaml
  spring:
   servlet:
     multipart:
       max-file-size: 10MB
```

### 4.上传图像实现方法

如何实现，调用腾讯云的cos ，将cos的cosClient注入容器  

如何解析图片属性   使用腾讯云的数据万象实现，提供上传图片的各种信息



# 四.用户上传图片以及审核

用户跟管理员共享上传api，但是用户上传后默认审核状态为待审核，管理员默认上传后过审



## url上传

重构上传方法，使用设计模式——模板方法  

声明一个抽象的父类，  使用url上传和文件上传继承并实现抽象方法，实现解耦



## 批量抓取图片  

本质是爬取图片网站，然后把图片上传到自己的cos



如何爬取到接口网站，小技巧，在图片网页，往下拉，获得新图片就会发送新的请求



解析文档用 Jsoup



bug：爬取的图片路径非常复杂，还有各种符号，抓取的图片链接

















# 五.图片优化查询

## **一、 缓存的核心思想**



为了提升图片等热点数据的访问速度，减轻数据库压力，我们采用多级缓存策略。核心逻辑是：**优先访问速度最快的缓存，逐级查询，最后才访问数据库**。



## **二、 缓存方案**

### **1. Redis 缓存（分布式缓存）**

- **作用**：作为主缓存层，在多个应用实例之间共享数据。
- **优点**：数据集中管理，应用重启后数据不丢失（配置持久化后）。
- **缺点**：需要通过网络读写，性能相比本地内存有损耗。
- **优化**：
  - **缓存雪崩**：当大量缓存（如同一批次的图片）在同一时间点同步失效时，会导致所有请求瞬间全部打向数据库，造成服务瘫痪。
  - **解决方案**：为不同的 Key 设置**随机的过期时间**，分散失效时间点，避免集中失效。

### **2. 本地缓存 (Caffeine)**

https://github.com/ben-manes/caffeine?tab=readme-ov-file

- **作用**：作为第一级缓存（L1 Cache），直接在应用服务器的内存中存储数据。
- **优点**：
  - **极致性能**：直接从内存读取，**无需网络传输**，速度极快，性能远高于 Redis。
  - **功能强大**：Caffeine 是 Java 主流的本地缓存技术，支持精确控制缓存数量、多种淘汰策略（如 LRU）、异步操作和线程安全。
- **缺点**：
  - 数据存储在单机内存中，无法在多个服务实例间共享。
  - 应用重启后，本地缓存会丢失。

```java
/**
 * 分页获取图片视图列表 (使用 Caffeine 本地缓存)
 */
@PostMapping("/list/page/vo/localCache")
@ApiOperation(value = "分页获取图片视图列表 本地缓存")
public BaseResponse<Page<PictureVO>> listPictureVOByPageWithLocalCache(@RequestBody PictureQueryRequest pictureQueryRequest, HttpServletRequest request) {
    // ... (省略参数校验、分页限制等前置代码)

    // 1. 生成缓存 Key
    // 将整个查询请求对象转换为 JSON 字符串
    String jsonStr = JSONUtil.toJsonStr(pictureQueryRequest);
    // 对 JSON 字符串进行 MD5 哈希，生成唯一的 Key
    String hashKey = DigestUtils.md5DigestAsHex(jsonStr.getBytes());
    String cacheKey = String.format("cloudimage:listPictureVOByPage:%s", hashKey);

    // 2. 查询本地缓存
    String cachedValue = LOCAL_CACHE.getIfPresent(cacheKey);
    if (cachedValue != null) {
        // 缓存命中：将 JSON 字符串反序列化为 Page 对象并直接返回
        Page<PictureVO> cachedPage = JSONUtil.toBean(cachedValue, Page.class);
        return ResultUtils.success(cachedPage);
    }

    // 3. 缓存未命中：查询数据库
    Page<Picture> picturePage = pictureService.page(new Page<>(current, size),
            pictureService.getQueryWrapper(pictureQueryRequest));

    // 4. 将数据库结果转换为 VO
    Page<PictureVO> pictureVOPage = pictureService.getPictureVOPage(picturePage, request);
    
    // 5. 将结果存入本地缓存
    String cacheValue = JSONUtil.toJsonStr(pictureVOPage);
    LOCAL_CACHE.put(cacheKey, cacheValue);

    // 6. 返回结果
    return ResultUtils.success(pictureVOPage);
}
```

## **三、 多级缓存（L1 + L2 架构）**

结合本地缓存和 Redis 缓存，构建一个更健壮、性能更高的多级缓存体系。

- **读取流程**：
  1. **查 L1 (Caffeine 本地缓存)**：优先从本地内存中读取数据。如果命中，直接返回。
  2. **查 L2 (Redis 分布式缓存)**：如果本地缓存未命中，则查询 Redis。
  3. **L2 命中**：如果 Redis 命中，将数据返回给用户，并**同时写入本地缓存**（L1），以便下次能更快访问。
  4. **L2 未命中**：查询数据库，并将结果**同时写入 Redis (L2) 和本地缓存 (L1)**，最后返回给用户。
- **数据更新**：当数据发生变更时（如图片被删除或修改），必须**同时失效（删除）** L2 (Redis) 和 L1 (本地缓存) 中的数据，以保证数据一致性。

## **四、 缓存的经典问题与解决方案**

1. **缓存击穿**
   - **现象**：某个**热点数据**（如爆款图片）的缓存刚过期，瞬间有大量并发请求访问这个数据，导致这些请求全部穿透到数据库，造成压力。
   - **解决方案**：
     - 设置热点数据永不过期或超长过期时间。
     - 使用**互斥锁**（如 Redisson 的 `RLock`）：当缓存未命中时，只允许第一个请求去查询数据库并写回缓存，其他请求短暂等待后直接读取新写入的缓存。
2. **缓存穿透**
   - **现象**：用户（或黑客）频繁请求一个**数据库中根本不存在**的数据。每次请求都会穿透缓存，直接打到数据库，导致数据库压力。
   - **解决方案**：
     - **缓存空值**：当数据库查询不到结果时，也在 Redis 中缓存一个特殊的空值（如 `null` 或 `""`），并设置一个较短的过期时间。
     - **布隆过滤器 (Bloom Filter)**：一种高效的数据结构，用于快速判断一个元素“一定不存在”或“可能存在”，在缓存之前拦截掉无效请求。
3. **缓存雪崩**
   - **现象**：大量缓存数据在**同一时刻**集体过期，导致所有请求都打向数据库，造成系统崩溃。
   - **解决方案**：
     - **设置随机过期时间**：在基础过期时间上增加一个随机值，错开失效时间点。
     - 使用多级缓存，L1 和 L2 同时失效的概率极低。





# 五.图片上传优化

### 1. 腾讯云数据万象 (CI) 处理



- **核心思想**：在图片上传时，利用腾讯云的数据万象服务，为不同的应用场景生成不同规格的图片。
- **具体实现**：
  - 在数据万象中添加新规则，生成 `webp` 格式的缩略图。
  - 每次上传原始图片时，数据万象会根据预设规则自动处理并存储多个版本（如 `original.jpg`, `thumbnail.webp`）。
- **优势**：在分页查询等需要展示缩略图的场景下，直接调用 `webp` 格式的小图，可以极大节省用户流量，提升加载速度。



### 2. 前端加载优化



#### 2.1 懒加载 (Lazy Loading)

- **定义**：一种前端优化策略，仅在资源（如下方的图片）进入浏览器可视区域时才开始加载。
- **工作方式**：先不加载图片，当用户滚动页面，图片即将出现时，再发起请求获取图片。
- **优势**：减少了页面的初始加载时间，节省了带宽，特别是对于图片较多的长页面效果显著。

#### 2.2 渐进式加载 (Progressive Loading)

- **定义**：与懒加载类似，但体验更平滑。它会先加载一个低分辨率或模糊的占位图，在真实图片完全加载后替换占位图。
- **适用场景**：适用于高清大图、对用户体验要求高的页面。在网络环境较差时，能有效避免长时间的白屏等待。
- **实现**：通常可以通过前端组件库或相关插件来实现。

### 3. CDN 加速

- **定义**：内容分发网络（Content Delivery Network）。将图片等静态资源缓存到全球各地的边缘节点服务器上。
- **工作方式**：用户访问时，会从地理位置最近的节点获取资源，从而缩短网络延迟。
- **优势**：显著提升全球用户的访问速度和稳定性。

### 4. 数据沉降

- **定义**：一种数据生命周期管理策略，根据数据的访问频率将其存储在不同成本的存储介质中。
- **实现**：将低频访问的冷数据（如用户几年前上传的图片）从高性能、高成本的存储（如 SSD 云盘）迁移到低成本的归档存储中。
- **优势**：在保证数据可用性的前提下，有效降低长期存储成本。

------



# 六、空间模块



### 1. 如何在不侵入原有代码的情况下开发新功能？

- **核心思想**：**代码复用**与**逻辑抽象**。
- **实践**：当新模块（如 “空间模块”）与现有模块（如 “图片模块”）的 `Service` 和 `Controller` 逻辑高度相似时：
  1. 可以考虑将通用的逻辑（如增删改查、权限校验等）抽象成一个公共的父类或工具类。
  2. 新的 `Service` 和 `Controller` 只需继承或调用这些公共组件，并实现其特有的业务逻辑即可。
  3. 这样可以最大限度地复用代码，同时保持新旧模块的独立性。

### 2. 核心代码示例：为用户创建私有空间（含并发控制）

- **业务场景**：确保每个用户只能创建一个私有空间，防止并发请求导致数据错乱。

```java
// 针对特定用户 ID 进行加锁，减小锁的粒度，提高并发性能
String lock = String.valueOf(userId).intern();

// 使用 synchronized 本地锁
synchronized (lock) {
    // 使用 Spring 编程式事务，确保事务范围在锁的保护之内
    Long newSpaceId = transactionTemplate.execute(status -> {
        // 1. 检查该用户是否已存在空间
        boolean exists = this.lambdaQuery().eq(Space::getUserId, userId).exists();
        ThrowUtils.throwIf(exists, ErrorCode.OPERATION_ERROR, "每个用户仅能有一个私有空间");

        // 2. 写入数据库
        // 此处 space 对象已在外部创建并设置好属性
        ThrowUtils.throwIf(!this.save(space), ErrorCode.OPERATION_ERROR);

        // 3. 返回新创建的空间 ID
        return space.getId();
    });

    // Optional 包装返回值，处理可能为 null 的情况
    return Optional.ofNullable(newSpaceId).orElse(-1L);
}
```

**为什么不使用 `@Transactional` 注解？**

@Transactional` 注解依赖 AOP 实现，其事务的提交是在整个方法执行完毕后。如果锁在方法内部，可能会出现 **锁已释放但事务尚未提交** 的情况，这在高并发下仍然会导致数据不一致。

**代码要点分析**：

1. **并发控制**：使用 `synchronized (String.valueOf(userId).intern())` 对用户 ID 进行加锁。这是一种巧妙的方式，`intern()` 方法会从字符串常量池中获取锁对象，确保了相同的 `userId` 会获得同一个锁，而不同的 `userId` 则使用不同的锁，实现了**分段锁**的效果，降低了锁冲突的概率。
2. **事务管理**：使用 Spring 的 `TransactionTemplate` (编程式事务) 而不是 `@Transactional` (声明式事务)。这样做可以将事务的提交和回滚精确地控制在 `synchronized` 同步代码块内部，保证了**加锁范围完全覆盖事务范围**，避免了在事务提交前释放锁可能导致的并发问题。
3. **测试建议**：在测试涉及事务的操作时，可以手动在业务逻辑中 `throw new RuntimeException()` 来验证事务是否按预期回滚。







# 七.图片搜索

## 1.以图搜图



以图搜图在全网搜

通用功能，使用第三方api或者爬虫



本项目抓取百度的以图搜图

https://graph.baidu.com/pcpage/index?tpl_from=pc

点击查询接口会发送 upload请求   返回结果为以图搜图结果页面

抓取这个页面相应信息的  first url   里面有所有图片的信息  在前端信息中找到  firstUrl的值

https://graph.baidu.com/ajax/pcsimi?carousel=503&entrance=GENERAL&extUiData%5BisLogoShow%5D=1&inspire=general_pc&limit=30&next=2&render_type=card&session_id=16607054484936936450&sign=1268849449a1ec9997acd01761303290&tk=8f337&tpl_from=pc

里面为干净的相似图片的json文件



一个新的设计模式   --门面模式

简单来说就是把几个功能封装到一个功能，  就像去酒店只用说需求就能入住

## 2.颜色搜图

为了提升性能,避免每次搜索都实时计算图片主色调,建议在图片上传成功后立即提取主色调并存储到数据库的独立字段中。
完整流程如下：
1,提取图片颜色:通过图像处理技术(云服务API或者OpenCV图像处理库)提取图片的颜色特征,可以采用主色调、颜色直方图等方法表示图片的颜色特征。此处我们采用主色调,便于理解。
2,存储颜色特征:将提取的颜色数据存储到数据库中,以便后续快速检索。
3,用户查询输入:用户通过颜色选择器、RGB值输入、或预定义颜色名称指定颜色查询条件。
4,计算相似度:根据用户指定的颜色,与数据库中的颜色特征进行相似度计算(如欧氏距离、余弦相似度等方法)。
5,返回结果:由于空间内的图片数量相对较少,可以按照图片与目标颜色的相似度进行排序,优先返回最符合用户要求的图片,而不是仅返回完全符合指定色调的图片。





获取图片色调使用数据万象



计算相似度 使用  欧几里得距离   



数据万象获得的十六进制rgb有点问题  解决方法
https://blog.csdn.net/weixin_74879735/article/details/147034701?spm=1001.2014.3001.5502



 
