### **学习笔记：使用“模板方法”模式重构文件上传功能**





#### **一、 现状与痛点 (Old Design)**



在重构之前，`FileManager` 类 中的 `uploadPicture` 方法是一个“万能”方法，它独自完成了所有的上传逻辑。

- **原始职责**：校验 `MultipartFile` → 生成文件名 → 写临时文件 → COS 上传 → 解析图片信息 → 封装结果 → 删除临时文件。
- **痛点**：
  1. **强耦合**：功能与 `MultipartFile` 类型强绑定，无法复用。
  2. **扩展性差**：如果想增加“通过 URL 上传”的功能，只能在 `uploadPicture` 方法里堆砌 `if/else`，违反了“开闭原则”，代码会越来越臃肿。
  3. **职责不清**：一个方法承担了太多的职责（校验、文件处理、COS上传、异常清理），难以维护和测试。



#### **二、 重构目标 (Goal)**



1. **固化流程**：将文件上传的**不变的、固定的主流程**（如：生成文件名、上传到COS、封装结果、清理文件）固定下来。
2. **抽象差异**：将文件上传的**可变部分**（如：如何校验来源、如何获取文件名、如何转为临时文件）抽象成方法，交给子类去实现。
3. **易于扩展**：未来如果需要支持 Base64 字符串上传，只需再添加一个新子类即可，无需修改任何原有代码。



#### **三、 模板方法模式 (Template Method Pattern) 设计**



通过这个设计模式，我们将上传功能拆分为了一个“模板”和多个“实现”。



##### **1. 抽象模板类：`PictureUploadTemplate`**



这个类是整个重构的核心，它扮演着“**流程总指挥**”的角色。

- **`public final UploadPictureResult uploadPicture(...)` (模板方法)**
  - 这是**固定不变**的主流程，被 `final` 标记，防止子类重写。
  - 它**定义了**一个完整的、6步走的上传“骨架”：
    1. **校验来源**：`validPicture(inputSource);` (抽象)
    2. **生成文件名/路径**：`String uploadPath = ...` (固定)
    3. **处理来源为临时文件**：`processFile(inputSource, file);` (抽象)
    4. **上传到对象存储**：`cosManager.putPictureObject(...)` (固定)
    5. **封装返回结果**：`return buildResult(...);` (固定)
    6. **清理临时文件**：`finally { deleteTempFile(file); }` (固定)
- **`protected abstract ...` (抽象钩子方法)**
  - 这是模板中**可变**的部分，它将具体的实现“外包”给了子类：
    1. `validPicture(Object inputSource)`：如何校验这个来源？
    2. `getOriginFilename(Object inputSource)`：如何从这个来源获取原始文件名？
    3. `processFile(Object inputSource, File file)`：如何将这个来源的数据写入到服务器的临时文件中？



##### **2. 具体实现类 (子类)**



每个子类只需要“填空”，专注于实现那三个抽象的钩子方法即可。

- **`FilePictureUpload.java` (处理本地文件上传)**
  - **`validPicture`**：实现对 `MultipartFile` 对象的空值、大小、后缀名进行校验。
  - **`getOriginFilename`**：实现 `multipartFile.getOriginalFilename()`。
  - **`processFile`**：实现 `multipartFile.transferTo(file)`，将上传的文件流转存为服务器本地文件。
- **`UrlPictureUpload.java` (处理远程 URL 上传)**
  - **`validPicture`**：实现对 URL 字符串的格式、协议 (http/https) 进行校验，并通过 `HEAD` 请求提前检查文件的大小和类型 (Content-Type)。
  - **`getOriginFilename`**：实现从 URL 中提取文件名。
  - **`processFile`**：实现 `HttpUtil.downloadFile(fileUrl, file)`，将远程图片下载为服务器本地文件。



#### **四、 业务层调用**



重构后，在 Controller 或 Service 层，我们不再注入旧的 `FileManager`，而是根据不同的业务场景，注入具体的实现类。

Java

```
// Controller
@Autowired
private FilePictureUpload filePictureUpload; // 注入“文件上传”实现

@Autowired
private UrlPictureUpload urlPictureUpload; // 注入“URL上传”实现

@PostMapping("/upload")
public BaseResponse<UploadPictureResult> upload(MultipartFile file) {
    // 调用文件上传的模板
    return ResultUtils.success(filePictureUpload.uploadPicture(file, "common"));
}

@PostMapping("/uploadByUrl")
public BaseResponse<UploadPictureResult> uploadByUrl(String url) {
    // 调用 URL 上传的模板
    return ResultUtils.success(urlPictureUpload.uploadPicture(url, "common"));
}
```

**总结**：通过模板方法模式，我们将一个臃肿、难以维护的“万能方法”，重构为了一个高内 聚、低耦合、易于扩展的优雅架构。
