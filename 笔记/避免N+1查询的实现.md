## **一、 什么是 N+1 查询问题？**



N+1 问题是指在查询一个列表（“1”次查询）后，为了获取该列表中每条记录的关联信息，又在循环中对每条记录都执行了一次单独的查询（“N”次查询）。

**一个“N+1 问题”的错误示范：** 如果我们想查询一个图片列表，并**同时**获取每个图片对应的用户信息，错误的代码会这样做：

1. **第 1 次查询**：`SELECT * FROM picture LIMIT 10;` (获取了 N=10 条图片)
2. **开始循环**：遍历这 10 条图片。
3. **第 2 次查询**：`SELECT * FROM user WHERE id = ?` (根据第1张图片的 `userId` 查询)
4. **第 3 次查询**：`SELECT * FROM user WHERE id = ?` (根据第2张图片的 `userId` 查询)
5. ...
6. **第 N+1 次查询**：`SELECT * FROM user WHERE id = ?` (根据第10张图片的 `userId` 查询)

**结果**：为了获取10条图片及其作者，总共执行了 `1+N`（即 `1+10=11`）次数据库查询，性能极差。

## **二、 正确的解决方案：批量查询 + 内存组装**

```java
public Page<PictureVO> getPictureVOPage(Page<Picture> picturePage, HttpServletRequest request) {
        List<Picture> pictureList = picturePage.getRecords();
        Page<PictureVO> pictureVOPage = new Page<>(picturePage.getCurrent(), picturePage.getSize(), picturePage.getTotal());
        if (CollUtil.isEmpty(pictureList)) {
            return pictureVOPage;
        }
        // 对象列表 => 封装对象列表
        List<PictureVO> pictureVOList = pictureList.stream().map(PictureVO::objToVo).collect(Collectors.toList());
        // 1. 关联查询用户信息
        Set<Long> userIdSet = pictureList.stream().map(Picture::getUserId).collect(Collectors.toSet());
        Map<Long, List<User>> userIdUserListMap = userService.listByIds(userIdSet).stream()
                .collect(Collectors.groupingBy(User::getId));
        // 2. 填充信息
        pictureVOList.forEach(pictureVO -> {
            Long userId = pictureVO.getUserId();
            User user = null;
            if (userIdUserListMap.containsKey(userId)) {
                user = userIdUserListMap.get(userId).get(0);
            }
            pictureVO.setUser(userService.getUserVo(user));
        });
        pictureVOPage.setRecords(pictureVOList);
        return pictureVOPage;
    }
```



#### **步骤 1：收集所有需要查询的 ID (0 次数据库查询)**

首先，代码在内存中遍历已经查询到的图片列表 `pictureList`，并将所有需要查询的 `userId` 收集到一个 `Set` 集合中。`Set` 的特性会自动去除重复的 ID。

```java
// 从 pictureList 中，提取所有 getUserId 的结果，并收集到一个 Set 中
Set<Long> userIdSet = pictureList.stream()
        .map(Picture::getUserId)
        .collect(Collectors.toSet());
```

#### **步骤 2：一次性批量查询所有数据 (1 次数据库查询)**

这是最关键的一步。代码使用 `userService.listByIds(userIdSet)` 方法，MyBatis-Plus 会将其转换为一条 `IN` 语句，从而**一次性**从数据库中获取**所有**需要用到的用户信息。

```java
// 执行类似 SELECT * FROM user WHERE id IN (id1, id2, id3, ...) 的查询
Map<Long, List<User>> userIdUserListMap = userService.listByIds(userIdSet).stream()
        .collect(Collectors.groupingBy(User::getId));
```

- **`groupingBy(User::getId)`**：这是一个非常巧妙的优化。它将查询返回的 `List<User>` 转换为一个 `Map`（键是 `userId`，值是 `User` 对象），这使得后续的数据匹配变成了**极速的内存查找**。



#### **步骤 3：在内存中进行数据组装 (0 次数据库查询)**



最后，代码再次遍历图片列表，但这次它不再访问数据库。而是直接从上一步准备好的 `Map` 中，通过 `userId` 查找对应的 `User` 对象，并将其设置到 `pictureVO` 中。

Java

```java
// 填充信息
pictureVOList.forEach(pictureVO -> {
    Long userId = pictureVO.getUserId();
    User user = null;
    if (userIdUserListMap.containsKey(userId)) {
        // 直接从 Map 中获取用户，这是内存操作，速度极快
        user = userIdUserListMap.get(userId).get(0); 
    }
    pictureVO.setUser(userService.getUserVo(user));
});
```
